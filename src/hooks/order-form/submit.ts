
import { OrderFormData, OrderStatus } from "@/types/order";
import { ComponentData } from "@/types/order";
import { supabase } from "@/integrations/supabase/client";
import { toast } from "sonner";

export const submitOrder = async (
  orderDetails: OrderFormData,
  components: Record<string, ComponentData>,
  customComponents: ComponentData[]
): Promise<string | null> => {
  try {
    // Insert order - note: we're not specifying order_number as it's auto-generated by the database
    const { data: orderData, error: orderError } = await supabase
      .from('orders')
      .insert({
        company_name: orderDetails.company_name.trim(),
        company_id: orderDetails.company_id,
        sales_account_id: orderDetails.sales_account_id === 'none' ? null : orderDetails.sales_account_id,
        quantity: parseInt(orderDetails.quantity),
        bag_length: parseFloat(orderDetails.bag_length),
        bag_width: parseFloat(orderDetails.bag_width),
        rate: orderDetails.rate ? parseFloat(orderDetails.rate) : null,
        order_date: orderDetails.order_date,
        special_instructions: orderDetails.special_instructions || null,
        status: orderDetails.status || 'pending'
        // order_number is generated by a database trigger so we don't need to provide it
      } as any) // Use type assertion to bypass TypeScript's strict checking
      .select('id')
      .single();
    
    if (orderError) throw orderError;
    
    // Prepare components for insertion
    const allComponents = [
      ...Object.values(components),
      ...customComponents
    ].filter(Boolean);
    
    // Insert components if any
    if (allComponents.length > 0) {
      const orderQuantity = parseInt(orderDetails.quantity) || 1;
      
      const componentsToInsert = allComponents.map(comp => {
        return {
          order_id: orderData.id,
          component_type: comp.type,
          color: comp.color || null,
          size: comp.length && comp.width ? `${comp.length}x${comp.width}` : null,
          custom_name: comp.customName || null,
          material_id: comp.material_id && comp.material_id !== 'not_applicable' ? comp.material_id : null,
          roll_width: comp.roll_width ? parseFloat(comp.roll_width) : null,
          consumption: comp.consumption
        };
      });
      
      const { error: componentsError } = await supabase
        .from('order_components')
        .insert(componentsToInsert);
      
      if (componentsError) {
        console.error("Error saving components:", componentsError);
        toast.error("Error saving components");
      }
      
      // Update inventory quantities based on material usage
      await updateInventoryQuantities(componentsToInsert);
    }
    
    toast.success("Order created successfully");
    return orderData.id;
    
  } catch (error: any) {
    console.error("Error creating order:", error);
    toast.error(`Failed to create order: ${error.message}`);
    return null;
  }
};

// Update inventory quantities based on material usage
const updateInventoryQuantities = async (orderComponents: any[]) => {
  try {
    // Filter components with material_id and consumption
    const componentsWithMaterial = orderComponents.filter(
      comp => comp.material_id && comp.consumption
    );
    
    // Update inventory quantities for each material used
    for (const comp of componentsWithMaterial) {
      // Get current inventory quantity
      const { data: material } = await supabase
        .from('inventory')
        .select('quantity')
        .eq('id', comp.material_id)
        .single();
        
      if (material) {
        // Calculate new quantity
        const newQuantity = Math.max(0, material.quantity - comp.consumption);
        
        // Update inventory
        await supabase
          .from('inventory')
          .update({ quantity: newQuantity })
          .eq('id', comp.material_id);
      }
    }
  } catch (error) {
    console.error("Error updating inventory quantities:", error);
    toast.error("Failed to update inventory quantities");
  }
};
