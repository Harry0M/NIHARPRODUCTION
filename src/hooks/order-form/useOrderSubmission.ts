
import { useState } from "react";
import { supabase } from "@/integrations/supabase/client";
import { toast } from "@/hooks/use-toast";
import { OrderFormData } from "@/types/order";
import { validateComponentData, convertStringToNumeric } from "@/utils/orderFormUtils";

interface UseOrderSubmissionProps {
  orderDetails: OrderFormData;
  components: Record<string, any>;
  customComponents: any[];
  validateForm: () => boolean;
}

export function useOrderSubmission({
  orderDetails,
  components,
  customComponents,
  validateForm
}: UseOrderSubmissionProps) {
  const [submitting, setSubmitting] = useState(false);

  const handleSubmit = async (e: React.FormEvent): Promise<string | undefined> => {
    e.preventDefault();
    
    // Validate form before submission
    if (!validateForm()) {
      toast({
        title: "Form validation failed",
        description: "Please correct the highlighted fields",
        variant: "destructive"
      });
      return;
    }
    
    setSubmitting(true);
    
    try {
      // Prepare data for database insert
      const orderData = {
        company_name: orderDetails.company_id ? null : orderDetails.company_name,
        company_id: orderDetails.company_id,
        quantity: parseInt(orderDetails.total_quantity), // Use total quantity for the order
        bag_length: parseFloat(orderDetails.bag_length),
        bag_width: parseFloat(orderDetails.bag_width),
        border_dimension: orderDetails.border_dimension ? parseFloat(orderDetails.border_dimension) : null,
        rate: orderDetails.rate ? parseFloat(orderDetails.rate) : null,
        order_date: orderDetails.order_date,
        sales_account_id: orderDetails.sales_account_id || null,
        special_instructions: orderDetails.special_instructions || null
      };

      console.log("Submitting order data:", orderData);
      
      // Implement retry logic for order insertion
      let orderResult = null;
      let attempts = 0;
      const maxAttempts = 3;
      
      while (attempts < maxAttempts && !orderResult) {
        attempts++;
        
        try {
          // Insert the order - using type assertion to bypass the order_number requirement
          // since this is auto-generated by the database trigger
          const { data, error } = await supabase
            .from("orders")
            .insert(orderData as any)
            .select('id, order_number')
            .single();
          
          if (error) {
            console.error(`Order insertion attempt ${attempts} error:`, error);
            
            // If it's not a duplicate key error or we've reached max attempts, throw the error
            if (error.code !== '23505' || attempts >= maxAttempts) {
              throw error;
            }
            
            // For duplicate key errors, wait briefly and retry
            await new Promise(resolve => setTimeout(resolve, 100 * attempts));
          } else {
            // Success! Store the result and exit the retry loop
            orderResult = data;
            break;
          }
        } catch (insertError) {
          if (attempts >= maxAttempts) {
            throw insertError;
          }
        }
      }
      
      if (!orderResult) {
        throw new Error("Failed to create order after multiple attempts");
      }
      
      console.log("Order created successfully:", orderResult);
      
      // Process components if any exist
      const allComponents = [
        ...Object.values(components).filter(Boolean),
        ...customComponents
      ].filter(Boolean);
      
      console.log("Raw components to be saved:", allComponents);
      
      if (allComponents.length > 0) {
        // Create a properly formatted array of components with correct data types
        const componentsToInsert = allComponents
          .filter(comp => validateComponentData(comp))
          .map(comp => {
            // Determine correct component type - IMPORTANT: convert to lowercase to match database enum
            // The database expects component_type in lowercase, but UI might display it with capitalization
            const componentTypeRaw = comp.type === 'custom' ? 'custom' : comp.type;
            const componentType = componentTypeRaw.toLowerCase();
            
            console.log(`Converting component type from '${componentTypeRaw}' to '${componentType}'`);
            
            // Use proper size formatting or null
            const size = comp.length && comp.width 
              ? `${comp.length}x${comp.width}` 
              : null;
            
            // Get the appropriate custom name based on component type
            const customName = comp.type === 'custom' ? comp.customName : null;
            
            // Convert string values to appropriate types for numeric fields
            const gsmValue = convertStringToNumeric(comp.gsm);
            const rollWidthValue = convertStringToNumeric(comp.roll_width);
            const consumptionValue = convertStringToNumeric(comp.consumption);
            
            // Debug log for individual component
            console.log(`Preparing component ${componentType}:`, {
              originalType: comp.type,
              normalizedType: componentType,
              originalGsm: comp.gsm,
              originalRollWidth: comp.roll_width,
              originalConsumption: comp.consumption,
              convertedGsm: gsmValue,
              convertedRollWidth: rollWidthValue,
              convertedConsumption: consumptionValue,
              size,
              materialId: comp.material_id || null
            });
            
            return {
              order_id: orderResult.id,
              component_type: componentType,
              size,
              color: comp.color || null,
              gsm: gsmValue,
              custom_name: customName,
              material_id: comp.material_id || null,
              roll_width: rollWidthValue,
              consumption: consumptionValue
            };
        });

        // Additional debug log for final components array
        console.log("Formatted components to insert:", componentsToInsert);

        if (componentsToInsert.length > 0) {
          const { data: insertedComponents, error: componentsError } = await supabase
            .from("order_components")
            .insert(componentsToInsert)
            .select();
          
          if (componentsError) {
            console.error("Error saving components:", componentsError);
            console.error("Components that failed to save:", componentsToInsert);
            
            toast({
              title: "Error saving components",
              description: componentsError.message,
              variant: "destructive"
            });
          } else {
            console.log("Components saved successfully:", insertedComponents);
            
            // Success toast for components
            toast({
              title: "Components saved successfully",
              description: `${insertedComponents?.length || 0} components saved`
            });
            
            // NEW CODE: Update inventory based on consumed materials
            await updateInventoryForComponents(insertedComponents, orderResult.order_number);
          }
        } else {
          console.warn("No valid components to insert after validation");
        }
      } else {
        console.log("No components to save");
      }
      
      toast({
        title: "Order created successfully",
        description: `Order number: ${orderResult.order_number}`
      });

      return orderResult.id;
      
    } catch (error: any) {
      console.error("Error creating order:", error);
      toast({
        title: "Error creating order",
        description: error.message || "An unexpected error occurred",
        variant: "destructive"
      });
    } finally {
      setSubmitting(false);
    }
  };

  // NEW FUNCTION: Update inventory for consumed materials
  const updateInventoryForComponents = async (components: any[], orderNumber: string) => {
    try {
      // Filter components that have material_id and consumption
      const materialsToUpdate = components.filter(
        comp => comp.material_id && comp.consumption
      );

      if (materialsToUpdate.length === 0) {
        console.log("No materials to update in inventory");
        return;
      }
      
      console.log("Updating inventory for materials:", materialsToUpdate);
      
      // Process each material
      for (const component of materialsToUpdate) {
        // Get current stock information
        const { data: stockData, error: stockError } = await supabase
          .from("inventory")
          .select("id, material_name, quantity")
          .eq("id", component.material_id)
          .single();
          
        if (stockError) {
          console.error(`Error fetching stock for material ${component.material_id}:`, stockError);
          continue;
        }
        
        if (!stockData) {
          console.warn(`Material ${component.material_id} not found in inventory`);
          continue;
        }
        
        // Calculate new stock level
        const currentStock = stockData.quantity || 0;
        const consumedAmount = parseFloat(component.consumption);
        const newStock = Math.max(0, currentStock - consumedAmount);
        
        console.log(`Updating stock for ${stockData.material_name} (${component.material_id}):`, {
          currentStock,
          consumed: consumedAmount,
          newStock
        });
        
        // Update the stock level
        const { error: updateError } = await supabase
          .from("inventory")
          .update({ quantity: newStock })
          .eq("id", component.material_id);
          
        if (updateError) {
          console.error(`Error updating stock for material ${component.material_id}:`, updateError);
          continue;
        }
        
        // Create inventory transaction record
        const transactionData = {
          inventory_id: component.material_id,
          transaction_type: 'consumption',
          quantity: -consumedAmount, // Negative for consumption
          reference_type: 'order',
          reference_id: orderNumber,
          notes: `Consumed for Order #${orderNumber} - Component: ${component.component_type}`
        };
        
        const { error: transactionError } = await supabase
          .from("inventory_transactions")
          .insert(transactionData);
          
        if (transactionError) {
          console.error(`Error recording transaction for material ${component.material_id}:`, transactionError);
        } else {
          console.log(`Transaction recorded for material ${component.material_id}`);
        }
      }
      
      toast({
        title: "Inventory updated",
        description: `Stock levels updated for ${materialsToUpdate.length} materials`
      });
      
    } catch (error: any) {
      console.error("Error updating inventory:", error);
      toast({
        title: "Warning",
        description: "Failed to update some inventory items",
        variant: "destructive"
      });
    }
  };

  return {
    submitting,
    handleSubmit
  };
}
