
import { useState } from "react";
import { supabase } from "@/integrations/supabase/client";
import { showToast } from "@/components/ui/enhanced-toast";
import { OrderFormData } from "@/types/order";
import { validateComponentData, convertStringToNumeric } from "@/utils/orderFormUtils";
import { updateInventoryForOrderComponents } from "@/utils/inventoryUtils";

interface UseOrderSubmissionProps {
  orderDetails: OrderFormData;
  components: Record<string, any>;
  customComponents: any[];
  validateForm: () => boolean;
}

export function useOrderSubmission({
  orderDetails,
  components,
  customComponents,
  validateForm
}: UseOrderSubmissionProps) {
  const [submitting, setSubmitting] = useState(false);

  const handleSubmit = async (e: React.FormEvent): Promise<string | undefined> => {
    e.preventDefault();
    
    // Validate form before submission
    if (!validateForm()) {
      showToast({
        title: "Form validation failed",
        description: "Please correct the highlighted fields",
        type: "error"
      });
      return;
    }
    
    // Check if any components have materials selected
    const allComponents = [
      ...Object.values(components).filter(Boolean),
      ...customComponents
    ].filter(Boolean);
    
    const componentsWithMaterials = allComponents.filter(comp => comp.material_id);
    
    if (componentsWithMaterials.length === 0 && allComponents.length > 0) {
      showToast({
        title: "Missing material selection",
        description: "Please select materials for at least one component for inventory tracking",
        type: "warning"
      });
      // Allow submission to continue, but warn user about missing material selection
    }
    
    setSubmitting(true);
    
    try {
      // Prepare data for database insert
      const orderData = {
        company_name: orderDetails.company_id ? null : orderDetails.company_name,
        company_id: orderDetails.company_id,
        quantity: parseInt(orderDetails.total_quantity), // Use total quantity for the order
        bag_length: parseFloat(orderDetails.bag_length),
        bag_width: parseFloat(orderDetails.bag_width),
        border_dimension: orderDetails.border_dimension ? parseFloat(orderDetails.border_dimension) : null,
        rate: orderDetails.rate ? parseFloat(orderDetails.rate) : null,
        order_date: orderDetails.order_date,
        sales_account_id: orderDetails.sales_account_id || null,
        special_instructions: orderDetails.special_instructions || null
      };

      console.log("Submitting order data:", orderData);
      
      // Implement retry logic for order insertion
      let orderResult = null;
      let attempts = 0;
      const maxAttempts = 3;
      
      while (attempts < maxAttempts && !orderResult) {
        attempts++;
        
        try {
          // Insert the order - using type assertion to bypass the order_number requirement
          // since this is auto-generated by the database trigger
          const { data, error } = await supabase
            .from("orders")
            .insert(orderData as any) // Use type assertion to bypass TypeScript check
            .select('id, order_number')
            .single();
          
          if (error) {
            console.error(`Order insertion attempt ${attempts} error:`, error);
            
            // If it's not a duplicate key error or we've reached max attempts, throw the error
            if (error.code !== '23505' || attempts >= maxAttempts) {
              throw error;
            }
            
            // For duplicate key errors, wait briefly and retry
            await new Promise(resolve => setTimeout(resolve, 100 * attempts));
          } else {
            // Success! Store the result and exit the retry loop
            orderResult = data;
            break;
          }
        } catch (insertError) {
          if (attempts >= maxAttempts) {
            throw insertError;
          }
        }
      }
      
      if (!orderResult) {
        throw new Error("Failed to create order after multiple attempts");
      }
      
      console.log("Order created successfully:", orderResult);
      
      // Process components if any exist
      const allComponents = [
        ...Object.values(components).filter(Boolean),
        ...customComponents
      ].filter(Boolean);
      
      console.log("Raw components to be saved:", allComponents);
      
      if (allComponents.length > 0) {
        // Create a properly formatted array of components with correct data types
        const componentsToInsert = allComponents
          .filter(comp => validateComponentData(comp))
          .map(comp => {
            // Determine correct component type - IMPORTANT: convert to lowercase to match database enum
            // The database expects component_type in lowercase, but UI might display it with capitalization
            const componentTypeRaw = comp.type === 'custom' ? 'custom' : comp.type;
            const componentType = componentTypeRaw.toLowerCase();
            
            console.log(`Converting component type from '${componentTypeRaw}' to '${componentType}'`);
            
            // Use proper size formatting or null
            const size = comp.length && comp.width 
              ? `${comp.length}x${comp.width}` 
              : null;
            
            // Get the appropriate custom name based on component type
            const customName = comp.type === 'custom' ? comp.customName : null;
            
            // Convert string values to appropriate types for numeric fields
            const gsmValue = convertStringToNumeric(comp.gsm);
            const rollWidthValue = convertStringToNumeric(comp.roll_width);
            const consumptionValue = convertStringToNumeric(comp.consumption);
            
            // Debug log for individual component
            console.log(`Preparing component ${componentType}:`, {
              originalType: comp.type,
              normalizedType: componentType,
              originalGsm: comp.gsm,
              originalRollWidth: comp.roll_width,
              originalConsumption: comp.consumption,
              convertedGsm: gsmValue,
              convertedRollWidth: rollWidthValue,
              convertedConsumption: consumptionValue,
              size,
              materialId: comp.material_id || null
            });
            
            return {
              order_id: orderResult.id,
              component_type: componentType,
              size,
              color: comp.color || null,
              gsm: gsmValue,
              custom_name: customName,
              material_id: comp.material_id || null,
              roll_width: rollWidthValue,
              consumption: consumptionValue
            };
          });

        // Additional debug log for final components array
        console.log("Formatted components to insert:", componentsToInsert);

        if (componentsToInsert.length > 0) {
          const { data: insertedComponents, error: componentsError } = await supabase
            .from("order_components")
            .insert(componentsToInsert)
            .select();
          
          if (componentsError) {
            console.error("Error saving components:", componentsError);
            console.error("Components that failed to save:", componentsToInsert);
            
            showToast({
              title: "Error saving components",
              description: componentsError.message,
              type: "error"
            });
          } else {
            console.log("Components saved successfully:", insertedComponents);
            
            // Success toast for components
            showToast({
              title: "Components saved successfully",
              description: `${insertedComponents?.length || 0} components saved`,
              type: "success"
            });
            
            // Update inventory based on component consumption
            console.log("Updating inventory based on component consumption");
            try {
              const inventoryResult = await updateInventoryForOrderComponents(
                supabase,
                orderResult.id,
                orderResult.order_number,
                componentsToInsert
              );
              
              if (inventoryResult.success) {
                console.log("Inventory update successful:", inventoryResult.message);
                
                // Show more visible toast about inventory changes
                if (inventoryResult.updatedMaterials && inventoryResult.updatedMaterials.length > 0) {
                  const materialDetails = inventoryResult.updatedMaterials.map(
                    m => `${m.name}: ${m.previous.toFixed(2)} â†’ ${m.new.toFixed(2)} ${m.unit} (-${m.consumed.toFixed(2)})`
                  ).join('\n');
                  
                  showToast({
                    title: "Inventory Updated",
                    description: `${inventoryResult.message}. Material transactions have been recorded.`,
                    type: "success"
                  });
                } else {
                  showToast({
                    title: "Inventory updated",
                    description: inventoryResult.message,
                    type: "success"
                  });
                }
                
                // Force invalidate any transaction queries to ensure fresh data
                // This will help show the new transactions in the stock detail dialog
                setTimeout(() => {
                  // We don't have direct access to queryClient here, so we'll use localStorage
                  // as a communication channel to tell other components to refresh
                  try {
                    // Store the timestamp of the update
                    localStorage.setItem('last_inventory_update', new Date().toISOString());
                    // Store affected material IDs if available
                    if (inventoryResult.updatedMaterials && inventoryResult.updatedMaterials.length > 0) {
                      const materialIds = componentsToInsert
                        .filter(c => c.material_id)
                        .map(c => c.material_id);
                      localStorage.setItem('updated_material_ids', JSON.stringify(materialIds));
                      
                      // Notify the user about where to find the transactions
                      showToast({
                        title: "Transaction History Updated",
                        description: "Go to Inventory > Stock > View Details > Transactions to see material usage history",
                        type: "info"
                      });
                    }
                  } catch (e) {
                    // Ignore localStorage errors
                    console.warn("Could not store inventory update info in localStorage", e);
                  }
                }, 100);
                
              } else {
                console.error("Inventory update failed:", inventoryResult.errors);
                showToast({
                  title: "Inventory update failed",
                  description: inventoryResult.message || "An error occurred updating inventory",
                  type: "error"
                });
              }
            } catch (inventoryError: any) {
              console.error("Error updating inventory:", inventoryError);
              showToast({
                title: "Error updating inventory",
                description: inventoryError.message || "An error occurred updating inventory",
                type: "error"
              });
            }
          }
        } else {
          console.warn("No valid components to insert after validation");
        }
      } else {
        console.log("No components to save");
      }
      
      showToast({
        title: "Order created successfully",
        description: `Order number: ${orderResult.order_number}`,
        type: "success"
      });

      return orderResult.id;
      
    } catch (error: any) {
      console.error("Error creating order:", error);
      showToast({
        title: "Error creating order",
        description: error.message || "An unexpected error occurred",
        type: "error"
      });
    } finally {
      setSubmitting(false);
    }
  };

  return {
    submitting,
    handleSubmit
  };
}
